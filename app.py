# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11Mh5HM_txTeP1a2-eVvzBNupuQ9aNkxZ
"""

!pip install -q gradio pandas numpy matplotlib statsmodels

import os, re, pickle
from datetime import datetime
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter

try:
    from statsmodels.tsa.arima.model import ARIMA
    from statsmodels.tsa.statespace.sarimax import SARIMAX, SARIMAXResults
    HAVE_ARIMA = True
except Exception:
    HAVE_ARIMA = False

import gradio as gr

INTEGRATED_MODEL_PATH = "mejor_sarima.pkl"
INTEGRATED_CFG_PATH = "mejor_sarima_config.txt"
EPS = 1e-6  # para evitar log(0)

# --- helper: formato moneda Bolivia
def formato_moneda_bs(valor):
    try:
        valor = float(valor)
        txt = f"{valor:,.2f}"
        txt = txt.replace(",", "X").replace(".", ",").replace("X", ".")
        return "Bs " + txt
    except:
        return valor

# --- detección robusta de columnas mensuales ---
SPANISH_MONTHS = {'ene':1,'feb':2,'mar':3,'abr':4,'may':5,'jun':6,'jul':7,'ago':8,'sep':9,'oct':10,'nov':11,'dic':12}
MONTH_COL_RE = re.compile(r"(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)[-_]?\s?(\d{2,4})", re.IGNORECASE)

def detect_month_columns(df):
    cols = []
    for c in df.columns:
        if pd.isna(c):
            continue
        clean = str(c).replace("\n", " ").strip().lower()
        m = MONTH_COL_RE.search(clean)
        if m:
            mon_abbr = m.group(1).lower()
            year_s = m.group(2)
            y = int("20"+year_s) if len(year_s)==2 else int(year_s)
            month = SPANISH_MONTHS.get(mon_abbr)
            if month:
                cols.append((c, datetime(y, month, 1)))
    if len(cols) == 0 and df.shape[0] > 0:
        first = df.iloc[0].astype(str).tolist()
        for idx, cell in enumerate(first):
            cell_clean = str(cell).replace("\n"," ").strip().lower()
            m = MONTH_COL_RE.search(cell_clean)
            if m:
                colname = df.columns[idx]
                mon_abbr = m.group(1).lower()
                year_s = m.group(2)
                y = int("20"+year_s) if len(year_s)==2 else int(year_s)
                month = SPANISH_MONTHS.get(mon_abbr)
                if month:
                    cols.append((colname, datetime(y, month, 1)))
    return sorted(cols, key=lambda x: x[1])

def try_fix_header(df):
    cols = [str(c) for c in df.columns]
    unnamed_count = sum(1 for c in cols if 'unnamed' in c.lower())
    first = df.iloc[0].astype(str).str.lower().tolist() if df.shape[0]>0 else []
    indicator = sum(1 for v in first if any(k in v for k in ['codigo','cliente','ciudad','zona','nombre','ene','feb','mar','abr','may','jun','jul','ago','sep','oct','nov','dic']))
    if unnamed_count >= 3 or indicator > 2:
        new_header = df.iloc[0].fillna("").astype(str).tolist()
        df2 = df[1:].reset_index(drop=True)
        df2.columns = new_header
        df2 = df2.loc[:, [c for c in df2.columns if str(c).strip()!='']]
        return df2
    return df

def build_total_series(df, month_cols):
    colnames = [c for (c,_) in month_cols]
    tmp = df[colnames].replace('',0).fillna(0)
    for c in tmp.columns:
        tmp[c] = tmp[c].astype(str).str.replace(',', '.').str.replace(' ', '')
        tmp[c] = pd.to_numeric(tmp[c], errors='coerce').fillna(0.0)
    vals = tmp.sum(axis=0).values
    dates = [dt for (_,dt) in month_cols]
    s = pd.Series(vals, index=pd.DatetimeIndex(dates))
    s.index.name = 'ds'
    s.name = 'y'
    return s

def load_pickled_model(path=INTEGRATED_MODEL_PATH):
    if os.path.exists(path):
        try:
            with open(path,'rb') as f:
                return pickle.load(f)
        except Exception as e:
            print("Error cargando pickled model:", e)
            return None
    return None

def extract_orders_from_model_or_cfg(model_obj, cfg_path=INTEGRATED_CFG_PATH):
    order = None
    seasonal_order = None
    try:
        if hasattr(model_obj, "model"):
            ord_ = getattr(model_obj.model, "order", None)
            seas = getattr(model_obj.model, "seasonal_order", None)
            if ord_ is not None:
                order = ord_
            if seas is not None:
                seasonal_order = seas
    except Exception:
        pass
    if (order is None or seasonal_order is None) and os.path.exists(cfg_path):
        try:
            txt = open(cfg_path, "r").read()
            tuples = re.findall(r"\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)", txt)
            if tuples:
                order = eval(tuples[0])
                if len(tuples) > 1:
                    seasonal_order = eval(tuples[1])
                else:
                    m2 = re.search(r"\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)", txt)
                    if m2:
                        seasonal_order = eval(m2.group(0))
        except Exception as e:
            print("No se pudo parsear cfg:", e)
    return order, seasonal_order

# --- main: process and optionally refit (like your notebook) ---
def process_csv_total_refit(file_obj, months_ahead):
    # leer CSV
    try:
        df = pd.read_csv(file_obj.name, sep=';', engine='python')
    except Exception:
        try:
            df = pd.read_csv(file_obj.name)
        except Exception as e:
            return f"Error leyendo CSV: {e}", None, None, None, None, None

    df = try_fix_header(df)
    head5 = df.head(5)

    month_cols = detect_month_columns(df)
    if len(month_cols) == 0:
        return "No pude detectar columnas mensuales (ej: 'ene-22').", head5, None, None, None, None

    series = build_total_series(df, month_cols)
    last_ym = series.index.max().strftime("%Y-%m")
    periods = int(months_ahead)

    # cargar modelo pickled y extraer orders
    model_obj = load_pickled_model()
    order, seasonal_order = (None, None)
    if model_obj is not None:
        order, seasonal_order = extract_orders_from_model_or_cfg(model_obj)

    out_csv_path = None
    ui_table = None
    full_table_ci = None
    model_used = "ninguno"

    # Si tenemos order+seasonal y statsmodels disponibles
    if order is not None and seasonal_order is not None and HAVE_ARIMA:
        try:
            serie_full = series.copy()
            serie_log = np.log(serie_full + 1 + EPS)

            model_refit = SARIMAX(serie_log, order=order, seasonal_order=seasonal_order,
                                 enforce_stationarity=False, enforce_invertibility=False)
            res_refit = model_refit.fit(disp=False, maxiter=200)

            # forecast with IC
            fc_obj = res_refit.get_forecast(steps=periods)
            fc_log = fc_obj.predicted_mean
            ci_log = fc_obj.conf_int(alpha=0.05)

            # invert transform exactly as notebook
            fc_real = np.exp(fc_log) - 1.0
            ci_lower = np.exp(ci_log.iloc[:,0]) - 1.0
            ci_upper = np.exp(ci_log.iloc[:,1]) - 1.0

            # build month-end index starting next month-end
            last_month = series.index.max()
            start = (last_month + pd.offsets.MonthEnd(1))
            idx = pd.date_range(start=start, periods=periods, freq='M')

            fc_series = pd.Series(fc_real.values, index=idx, name='Predicho')
            ci_lower_s = pd.Series(ci_lower.values, index=idx, name='IC_lower')
            ci_upper_s = pd.Series(ci_upper.values, index=idx, name='IC_upper')

            # table full numeric (for export)
            full_df = pd.concat([fc_series.round(2), ci_lower_s.round(2), ci_upper_s.round(2)], axis=1)
            full_df.index.name = 'Fecha'
            full_df.reset_index(inplace=True)

            # --- UI: tabla formateada (Predicho) ---
            ui_df = full_df[['Fecha','Predicho']].copy()
            ui_df['Fecha'] = ui_df['Fecha'].dt.strftime('%Y-%m')
            ui_df['Predicho'] = ui_df['Predicho'].apply(formato_moneda_bs)
            ui_table = ui_df

            # --- TABLA COMPLETA: formateada CON Bs (Predicho + IC_lower + IC_upper) ---
            full_table_ci_fmt = full_df.copy()
            full_table_ci_fmt['Fecha'] = full_table_ci_fmt['Fecha'].dt.strftime('%Y-%m')
            full_table_ci_fmt['Predicho'] = full_table_ci_fmt['Predicho'].apply(formato_moneda_bs)
            full_table_ci_fmt['IC_lower'] = full_table_ci_fmt['IC_lower'].apply(formato_moneda_bs)
            full_table_ci_fmt['IC_upper'] = full_table_ci_fmt['IC_upper'].apply(formato_moneda_bs)
            full_table_ci = full_table_ci_fmt

            # --- CSV de salida (NUMÉRICO sin formato) ---
            out_csv_path = "/content/prediccion_2026_mejor_sarima_con_IC.csv"
            full_df.to_csv(out_csv_path, index=False)

            total_pred = float(fc_series.sum())
            summary = f"Última fecha: {last_ym}. Total proyectado {periods} meses: {formato_moneda_bs(total_pred)}"
            model_used = "refit (con IC)"
            # gráfico
            fig, ax = plt.subplots(figsize=(10,5))
            ax.plot(series.index, series.values, label='Histórico', marker='o')
            ax.plot(fc_series.index, fc_series.values, marker='o', linestyle='--', label='Predicción')
            ax.fill_between(fc_series.index, ci_lower_s.values, ci_upper_s.values, alpha=0.18, label='IC 95%')
            ax.set_title("Predicción")
            ax.set_xlabel("Fecha")
            ax.set_ylabel("Ingresos (Bs)")
            ax.legend()
            ax.yaxis.set_major_formatter(FuncFormatter(lambda x,pos: formato_moneda_bs(x)))
            plt.tight_layout()

            # return summary, head5, fig, ui_table, full_table_ci, out_csv_path
            return summary, head5, fig, ui_table, full_table_ci, out_csv_path

        except Exception as e:
            print("Error en refit/forecast:", e)
            # caemos al flujo fallback

    # --- fallback behavior (no refit or failed) ---
    pred = None
    if model_obj is not None:
        try:
            if hasattr(model_obj, "get_forecast"):
                fc = model_obj.get_forecast(steps=periods)
                raw = getattr(fc, "predicted_mean", None)
                if raw is not None:
                    rawvals = np.array(raw).ravel()
                    last = series.index[-1]
                    idx = pd.date_range(last + pd.offsets.MonthBegin(1), periods=len(rawvals), freq='MS')
                    pred = pd.Series(rawvals, index=idx)
                    model_used = "modelo pickled (get_forecast)"
        except Exception as e:
            print("Error usando pickled model get_forecast:", e)
            pred = None

    if pred is None and HAVE_ARIMA:
        try:
            arima = ARIMA(series.values, order=(1,1,1)).fit()
            raw = arima.predict(start=len(series), end=len(series)+periods-1)
            last = series.index[-1]
            idx = pd.date_range(last + pd.offsets.MonthBegin(1), periods=periods, freq='MS')
            pred = pd.Series(np.array(raw).ravel(), index=idx)
            model_used = "ARIMA local (fallback)"
        except Exception as e:
            pred = None

    if pred is None:
        avg = series.tail(3).mean() if len(series)>=1 else 0.0
        last = series.index[-1]
        idx = pd.date_range(last + pd.offsets.MonthBegin(1), periods=periods, freq='MS')
        pred = pd.Series([avg]*periods, index=idx)
        model_used = "naive (fallback)"

    # desescalar if looks like log-scale (exp -1)
    if looks_like_log_scale(pred):
        pred = np.exp(pred) - 1.0
        model_used += " (desescalado exp-1)"

    pred = pred.round(2)

    # prepare ui table and numeric full table (no IC)
    full_df = pd.DataFrame({
        'Fecha': pred.index,
        'Predicho': pred.values
    })
    full_df['Fecha'] = full_df['Fecha'].dt.strftime('%Y-%m')
    full_table_ci = full_df.copy()  # no IC columns here

    # format UI table
    ui_table = full_table_ci.copy()
    ui_table['Predicho'] = ui_table['Predicho'].apply(formato_moneda_bs)

    # save CSV for download (numeric)
    out_csv_path = "/content/prediccion_2026_mejor_sarima_sinIC.csv"
    full_table_ci.to_csv(out_csv_path, index=False)

    total_pred = float(pred.sum())
    summary = f"Última fecha: {last_ym}. Modelo usado: {model_used}. Total proyectado {periods} meses: {formato_moneda_bs(total_pred)}"

    # gráfico simple
    fig, ax = plt.subplots(figsize=(10,5))
    ax.plot(series.index, series.values, label='Histórico', marker='o')
    ax.plot(pred.index, pred.values, label='Predicción', linestyle='--', marker='o')
    ax.set_title("Predicción (fallback)")
    ax.yaxis.set_major_formatter(FuncFormatter(lambda x,pos: formato_moneda_bs(x)))
    ax.legend()
    plt.tight_layout()

    return summary, head5, fig, ui_table, full_table_ci, out_csv_path

# --- UI Gradio ---
with gr.Blocks() as demo:
    gr.Markdown("## Wymdis — Sistema de Predicción de Ingresos\nSube CSV;")
    csv_file = gr.File(label="Subir CSV")
    months = gr.Slider(1, 24, step=1, value=12, label="Meses (usualmente 12)")
    btn = gr.Button("Generar predicción")
    out_summary = gr.Textbox(label="Resumen")
    out_head = gr.Dataframe(label="Primeras 5 filas")
    out_plot = gr.Plot(label="Gráfico con IC")
    out_table = gr.Dataframe(label="Tabla predicción")
    out_table_ci = gr.Dataframe(label="Tabla completa")
    download = gr.File(label="Descargar CSV (predicción)")

    btn.click(fn=process_csv_total_refit, inputs=[csv_file, months], outputs=[out_summary, out_head, out_plot, out_table, out_table_ci, download])

demo.launch(share=True)